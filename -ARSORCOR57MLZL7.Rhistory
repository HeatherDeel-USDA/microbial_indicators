View(otu)
### Hops.2018
# we don't need the full phyloseq from before, so reimporting
func <- read.delim('../picrust2_files/Hops.2018/EC/pred_metagenome_contrib.tsv.gz', sep='\t')
df <- read.delim('../picrust2_files/Hops.2018/marker_predicted_and_nsti.tsv.gz', sep = '\t')
names(df) <- c("taxon", "genome_16S_count", "metadata_NSTI")
# combine two files
func <- func %>%
full_join(df, by="taxon")
# get other metadata
data.pred.SHMI <- readRDS('metadata/data.pred.SHMI.RDS')
# read in metadata that includes sampleIDs to merge with data.pred.SHMI
data.sampleID <- read.delim('metadata/SHAI.Meta.22March2023.q2.reduced.txt', sep = '\t')
# merge metadata files
data.merged <- merge(data.pred.SHMI, data.sampleID, by = "PLFA_ID", all.x = TRUE)
# move the sample ID column to the front
data.merged <- data.merged %>%
relocate(SampleID)
# get qPCR data into func
qPCR_data <- data.merged[,c(1,99)]
colnames(qPCR_data)[1] <- "sample"
func <- merge(func, qPCR_data, by = "sample")
# we imported un-normalized counts, so normalizing here
func$gene_counts <- func$taxon_rel_abun / 100 * func$genome_function_count / func$genome_16S_count * func$qPCR
# change column name "function" to "EC"
colnames(func)[2] <- "EC"
otu <- func %>%
group_by(sample, EC) %>%
summarize(sum=sum(gene_counts))
otu <- otu %>%
spread(key=sample, value=sum)
otu <- data.frame(otu)
otu[is.na(otu)] <- 0
row.names(otu) <- otu$EC
otu <- otu[,-1]
# transpose the "otu" table
otu <- t(otu)
# convert matrix to data frame
otu <- as.data.frame(otu)
# make the sample names a column for merging later
otu <- tibble::rownames_to_column(otu, "SampleID")
View(otu)
# merge metadata and "otu" table
hops2018_all <- merge(data.merged, otu, by = "SampleID")
hops2018_all <- as.data.frame(hops2018_all)
View(hops2018_all)
# select columns to be used in ml - SampleID, ECs, and "Overall" CASH rating
hops2018_ml <- hops2018_all[,c(1,95,152:2390)]
full_data <- read.delim("pred_metagenome_contrib.tsv.gz", sep = "\t")
library(tidymodels)
library(tidyverse)
library(workflows)
library(tune)
library(metagMisc)
library(ranger)
library(randomForest)
# get other metadata
data.pred.SHMI <- readRDS('metadata/data.pred.SHMI.RDS')
# read in metadata that includes sampleIDs to merge with data.pred.SHMI
data.sampleID <- read.delim('metadata/SHAI.Meta.22March2023.q2.reduced.txt', sep = '\t')
# merge metadata files
data.merged <- merge(data.pred.SHMI, data.sampleID, by = "PLFA_ID", all.x = TRUE)
# move the sample ID column to the front
data.merged <- data.merged %>%
relocate(SampleID)
# get qPCR data into func
qPCR_data <- data.merged[,c(1,99)]
colnames(qPCR_data)[1] <- "sample"
func1 <- readRDS("../picrust2_files/NRCS/EC/pred_metagenome_contrib1.RDS")
func2 <- readRDS("../picrust2_files/NRCS/EC/pred_metagenome_contrib2.RDS")
df <- read.delim('../picrust2_files/NRCS/marker_predicted_and_nsti.tsv.gz', sep = '\t')
names(df) <- c("taxon", "genome_16S_count", "metadata_NSTI")
# combine two files
func1 <- func1 %>%
full_join(df, by="taxon")
View(func1)
func2 <- func2 %>%
full_join(df, by="taxon")
# add qPCR data to new func object
func1 <- merge(func1, qPCR_data, by = "sample")
func2 <- merge(func2, qPCR_data, by = "sample")
# we imported un-normalized counts, so normalizing here
func1$gene_counts <- func1$taxon_rel_abun / 100 * func1$genome_function_count / func1$genome_16S_count * func1$qPCR
func2$gene_counts <- func2$taxon_rel_abun / 100 * func2$genome_function_count / func2$genome_16S_count * func2$qPCR
# change column name "function" to "EC"
colnames(func1)[2] <- "EC"
colnames(func2)[2] <- "EC"
otu1 <- func1 %>%
group_by(sample, EC) %>%
summarize(sum=sum(gene_counts))
otu1 <- otu1 %>%
spread(key=sample, value=sum)
otu1 <- data.frame(otu1)
otu1[is.na(otu1)] <- 0
row.names(otu1) <- otu1$EC
otu1 <- otu1[,-1]
otu2 <- func2 %>%
group_by(sample, EC) %>%
summarize(sum=sum(gene_counts))
otu2 <- otu2 %>%
spread(key=sample, value=sum)
otu2 <- data.frame(otu2)
otu2[is.na(otu2)] <- 0
row.names(otu2) <- otu2$EC
otu2 <- otu2[,-1]
# transpose the "otu" table
otu1 <- t(otu1)
otu2 <- t(otu2)
# convert matrix to data frame
otu1 <- as.data.frame(otu1)
otu2 <- as.data.frame(otu2)
# make the sample names a column for merging later
otu1 <- tibble::rownames_to_column(otu1, "SampleID")
otu2 <- tibble::rownames_to_column(otu2, "SampleID")
# merge metadata and "otu" table
NRCS1 <- merge(data.merged, otu1, by = "SampleID")
NRCS1 <- as.data.frame(NRCS1)
NRCS2 <- merge(data.merged, otu2, by = "SampleID")
NRCS2 <- as.data.frame(NRCS2)
View(NRCS1)
### remember to check column numbers for this command
NRCS1_ml <- NRCS1[,c(1,95,152:2530)]
NRCS2_ml <- NRCS2[,c(1,95,152:2468)]
saveRDS(NRCS1_ml, "machine_learning/NRCS1_ml_EC.RDS")
saveRDS(NRCS2_ml, "machine_learning/NRCS2_ml_EC.RDS")
### Rangeland
# we don't need the full phyloseq from before, so reimporting
func <- read.delim('../picrust2_files/Rangeland/EC/pred_metagenome_contrib.tsv.gz', sep='\t')
df <- read.delim('../picrust2_files/Rangeland/marker_predicted_and_nsti.tsv.gz', sep = '\t')
names(df) <- c("taxon", "genome_16S_count", "metadata_NSTI")
# combine two files
func <- func %>%
full_join(df, by="taxon")
# add qPCR data to new func object
func <- merge(func, qPCR_data, by = "sample")
# we imported un-normalized counts, so normalizing here
func$gene_counts <- func$taxon_rel_abun / 100 * func$genome_function_count / func$genome_16S_count * func$qPCR
# change column name "function" to "EC"
colnames(func)[2] <- "EC"
# pool data by sample and function
otu <- func %>%
group_by(sample, EC) %>%
summarize(sum=sum(gene_counts))
otu <- otu %>%
spread(key=sample, value=sum)
otu <- data.frame(otu)
otu[is.na(otu)] <- 0
row.names(otu) <- otu$EC
otu <- otu[,-1]
# transpose the "otu" table
otu <- t(otu)
# convert matrix to data frame
otu <- as.data.frame(otu)
# make the sample names a column for merging later
otu <- tibble::rownames_to_column(otu, "SampleID")
# merge metadata and "otu" table
rangeland_all <- merge(data.merged, otu, by = "SampleID")
rangeland_all <- as.data.frame(rangeland_all)
# select columns to be used in ml - SampleID, ECs, and "Overall" CASH rating
rangeland_ml <- rangeland_all[,c(1,95,152:2391)]
saveRDS(rangeland_ml, "machine_learning/rangeland_ml_EC.RDS")
ml_1 <- merge(hops2018_ml, hopsARS_ml, all = TRUE)
hops2018_ml <- readRDS("machine_learning/hops2018_ml_EC.RDS")
hopsARS_ml <- readRDS("machine_learning/hopsARS_ml_EC.RDS")
ml_1 <- merge(hops2018_ml, hopsARS_ml, all = TRUE)
View(ml_1)
ml_2 <- merge(NRCS1, ml_1, all = TRUE)
View(ml_2)
ml_3 <- merge(NRCS2, ml_2, all = TRUE)
View(ml_3)
ml_1 <- merge(hops2018_ml, hopsARS_ml, all = TRUE)
ml_2 <- merge(NRCS1_ml, ml_1, all = TRUE)
ml_3 <- merge(NRCS2_ml, ml_2, all = TRUE)
ml_all <- merge(rangeland_ml, ml_3, all = TRUE)
View(ml_all)
# going to assume that NAs are 0 (functions not found in one data set or another)
# change NAs to 0
ml_all[is.na(ml_all)] <- 0
# make the sample names the row names again to make selecting columns for ml easy
rownames(ml_all) <- ml_all$SampleID
# NRCS 346 duplicated for some reason. One row is all zeros. Get rid of row 316
ml_all <- ml_all[1:315,317:537]
ml_1 <- merge(hops2018_ml, hopsARS_ml, all = TRUE)
ml_2 <- merge(NRCS1_ml, ml_1, all = TRUE)
ml_3 <- merge(NRCS2_ml, ml_2, all = TRUE)
ml_all <- merge(rangeland_ml, ml_3, all = TRUE)
# going to assume that NAs are 0 (functions not found in one data set or another)
# change NAs to 0
ml_all[is.na(ml_all)] <- 0
# NRCS 346 duplicated for some reason. One row is all zeros. Get rid of row 316
ml_all <- ml_all[c(1:315,317:537),]
# make the sample names the row names again to make selecting columns for ml easy
rownames(ml_all) <- ml_all$SampleID
# get rid of sampleID column
ml_all <- ml_all[,c(2:2444)]
# check for any NAs in ml_all
sum(is.na(ml_all))
# save ML object
saveRDS(ml_all, "machine_learning/ml_all_EC.RDS")
data.pred.SHMI <- readRDS("metadata/data.pred.SHMI.RDS")
View(data.pred.SHMI)
write.table(data.pred.SHMI, file = "data.pred.SHMI.txt", sep = "\t",
row.names = FALSE)
write.table(data.pred.SHMI, file = "metadata/data.pred.SHMI.txt", sep = "\t",
row.names = FALSE)
library(tidymodels)
library(tidyverse)
library(workflows)
library(tune)
library(metagMisc)
library(ranger)
library(randomForest)
func1 <- readRDS("picrust2_files/NRCS/EC/pred_metagenome_contrib1.RDS")
func2 <- readRDS("picrust2_files/NRCS/EC/pred_metagenome_contrib2.RDS")
df <- read.delim('picrust2_files/NRCS/marker_predicted_and_nsti.tsv.gz', sep = '\t')
names(df) <- c("taxon", "genome_16S_count", "metadata_NSTI")
func1 <- func1 %>%
full_join(df, by="taxon")
func2 <- func2 %>%
full_join(df, by="taxon")
# read in qPCR data from local env instead of scinet
qPCR_data <- read.delim('metadata/SHAI.Meta.22March2023.q2.qPCR.txt', sep = '\t')
qPCR_data <- qPCR_data %>%
filter(!is.na(qPCR))
gc()
# add qPCR data to new func object
func1 <- merge(func1, qPCR_data, by = "sample")
gc()
# clear unused R memory again
func2 <- merge(func2, qPCR_data, by = "sample")
# we imported un-normalized counts, so normalizing here
func1$gene_counts <- func1$taxon_rel_abun / 100 * func1$genome_function_count / func1$genome_16S_count * func1$qPCR
func2$gene_counts <- func2$taxon_rel_abun / 100 * func2$genome_function_count / func2$genome_16S_count * func2$qPCR
# change column name "function" to "EC"
colnames(func1)[2] <- "EC"
colnames(func2)[2] <- "EC"
otu1 <- func1 %>%
group_by(sample, EC) %>%
summarize(sum=sum(gene_counts))
otu1 <- otu1 %>%
spread(key=sample, value=sum)
otu1 <- data.frame(otu1)
otu1[is.na(otu1)] <- 0
row.names(otu1) <- otu1$EC
otu1 <- otu1[,-1]
otu2 <- func2 %>%
group_by(sample, EC) %>%
summarize(sum=sum(gene_counts))
otu2 <- otu2 %>%
spread(key=sample, value=sum)
otu2 <- data.frame(otu2)
otu2[is.na(otu2)] <- 0
row.names(otu2) <- otu2$EC
otu2 <- otu2[,-1]
# transpose the "otu" table
otu1 <- t(otu1)
otu2 <- t(otu2)
# convert matrix to data frame
otu1 <- as.data.frame(otu1)
otu2 <- as.data.frame(otu2)
# make the sample names a column for merging later
otu1 <- tibble::rownames_to_column(otu1, "SampleID")
otu2 <- tibble::rownames_to_column(otu2, "SampleID")
NRCS1 <- merge(data.merged, otu1, by = "SampleID")
# merge metadata and "otu" table
# reread in data.merged from local drive
data.pred.SHMI <- readRDS('metadata/data.pred.SHMI.RDS')
# read in metadata that includes sampleIDs to merge with data.pred.SHMI
data.sampleID <- read.delim('metadata/SHAI.Meta.22March2023.q2.reduced.txt', sep = '\t')
# merge metadata files
data.merged <- merge(data.pred.SHMI, data.sampleID, by = "PLFA_ID", all.x = TRUE)
# move the sample ID column to the front
data.merged <- data.merged %>%
relocate(SampleID)
NRCS1 <- merge(data.merged, otu1, by = "SampleID")
NRCS1 <- as.data.frame(NRCS1)
NRCS2 <- merge(data.merged, otu2, by = "SampleID")
NRCS2 <- as.data.frame(NRCS2)
View(NRCS1)
# select columns to be used in ml - SampleID, ECs, and "Overall" CASH rating
NRCS1_ml <- NRCS1[,c(1,95,152:2530)]
View(NRCS1_ml)
View(NRCS1)
View(NRCS2)
# select columns to be used in ml - SampleID, ECs, and "Overall" CASH rating
NRCS1_ml <- NRCS1[,c(1,95,152:2534)]
NRCS2_ml <- NRCS2[,c(1,95,152:2472)]
saveRDS(NRCS1_ml, "machine_learning/NRCS1_ml_EC.RDS")
saveRDS(NRCS2_ml, "machine_learning/NRCS2_ml_EC.RDS")
saveRDS(NRCS1_ml, "machine_learning/16S_EC/NRCS1_ml_EC.RDS")
saveRDS(NRCS2_ml, "machine_learning/16S_EC/NRCS2_ml_EC.RDS")
gc()
library(ggplot2)
library(readxl)
ml_stats <- read_xlsx("machine_learning/16S_EC/ALL_ec_16S_stats.xlsx")
View(ml_stats)
stat.test <- compare_means(r2_value_pred_vs_obs ~ prediction,
data = ml_stats,
method = 'wilcox.test',
p.adj = 'fdr')
library(ggpubr)
stat.test <- compare_means(r2_value_pred_vs_obs ~ prediction,
data = ml_stats,
method = 'wilcox.test',
p.adj = 'fdr')
stat.test$Comparison <- paste0(stat.test$group1, " - ", stat.test$group2)
groups <- rcompanion::cldList(p.adj ~ Comparison,
data = stat.test,
threshold = 0.05)
View(groups)
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
#scale_fill_brewer(palette="Dark2", labels = c("Annual Cropland", "Perennial Cropland", "Rangeland")) +
geom_boxplot(fill='grey') +
#labs(y='SOM, adjusted', x='', fill='Land Use') +
theme_bw() +
#theme(legend.position = "none", axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter)) +
#ylim(0, 10)
#scale_x_discrete(labels = c("cover crop" = "Cover Crop", "perennial" = "Perennial"))
p1
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
#scale_fill_brewer(palette="Dark2", labels = c("Annual Cropland", "Perennial Cropland", "Rangeland")) +
geom_boxplot(fill='grey') +
#labs(y='SOM, adjusted', x='', fill='Land Use') +
theme_bw() +
#theme(legend.position = "none", axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter)) +
#ylim(0, 10)
#scale_x_discrete(labels = c("cover crop" = "Cover Crop", "perennial" = "Perennial"))
p1
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
#scale_fill_brewer(palette="Dark2", labels = c("Annual Cropland", "Perennial Cropland", "Rangeland")) +
geom_boxplot(fill='grey') +
#labs(y='SOM, adjusted', x='', fill='Land Use') +
theme_bw() +
#theme(legend.position = "none", axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter))
#ylim(0, 10)
#scale_x_discrete(labels = c("cover crop" = "Cover Crop", "perennial" = "Perennial"))
p1
groups$y <- 7
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
#scale_fill_brewer(palette="Dark2", labels = c("Annual Cropland", "Perennial Cropland", "Rangeland")) +
geom_boxplot(fill='grey') +
#labs(y='SOM, adjusted', x='', fill='Land Use') +
theme_bw() +
#theme(legend.position = "none", axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter))
#ylim(0, 10)
#scale_x_discrete(labels = c("cover crop" = "Cover Crop", "perennial" = "Perennial"))
p1
groups$y <- 1
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
#scale_fill_brewer(palette="Dark2", labels = c("Annual Cropland", "Perennial Cropland", "Rangeland")) +
geom_boxplot(fill='grey') +
#labs(y='SOM, adjusted', x='', fill='Land Use') +
theme_bw() +
#theme(legend.position = "none", axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter))
#ylim(0, 10)
#scale_x_discrete(labels = c("cover crop" = "Cover Crop", "perennial" = "Perennial"))
p1
groups$y <- 0.8
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
#scale_fill_brewer(palette="Dark2", labels = c("Annual Cropland", "Perennial Cropland", "Rangeland")) +
geom_boxplot(fill='grey') +
#labs(y='SOM, adjusted', x='', fill='Land Use') +
theme_bw() +
#theme(legend.position = "none", axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter))
#ylim(0, 10)
#scale_x_discrete(labels = c("cover crop" = "Cover Crop", "perennial" = "Perennial"))
p1
groups$y <- 0.9
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
#scale_fill_brewer(palette="Dark2", labels = c("Annual Cropland", "Perennial Cropland", "Rangeland")) +
geom_boxplot(fill='grey') +
#labs(y='SOM, adjusted', x='', fill='Land Use') +
theme_bw() +
#theme(legend.position = "none", axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter))
#ylim(0, 10)
#scale_x_discrete(labels = c("cover crop" = "Cover Crop", "perennial" = "Perennial"))
p1
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
geom_boxplot(fill='grey') +
labs(y='R^2 Values', x='Prediction Type') +
theme_bw() +
#theme(legend.position = "none", axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter))
#ylim(0, 10)
#scale_x_discrete(labels = c("cover crop" = "Cover Crop", "perennial" = "Perennial"))
p1
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
geom_boxplot(fill='grey') +
labs(y='R^2 Values', x='Prediction Type') +
theme_bw() +
theme(axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter))
#ylim(0, 10)
#scale_x_discrete(labels = c("cover crop" = "Cover Crop", "perennial" = "Perennial"))
p1
# reordering from highest to lowest r^2 values
ml_stats$prediction <- factor(ml_stats$prediction, levels = c('ACE','ACTIVEC',
'SHMI','SOM','DIST',
'CASH','RESP','ROOT',
'AGGSTAB','WATERCAP',
'SEMWISE','RICH'))
p1 <- ggplot(ml_stats, aes(x=prediction, y=r2_value_pred_vs_obs)) +
geom_boxplot(fill='grey') +
labs(y='R^2 Values', x='Prediction Type') +
theme_bw() +
theme(axis.text.x=element_text(angle=45, hjust=1)) +
geom_text(inherit.aes=F, data=groups, aes(x=Group, y=y, label=Letter))
p1
ggsave("machine_learning/16S_EC/16S_EC_ml_r2.tiff", unit = "in", width = 6, height = 6, dpi = 300, device = "tiff")
library(tidymodels)
library(tidyverse)
library(workflows)
library(tune)
library(metagMisc)
library(ranger)
library(randomForest)
library(tidymodels)
library(tidyverse)
library(workflows)
library(tune)
library(metagMisc)
library(ranger)
library(randomForest)
func <- read.delim('picrust2_files/18S/EC_metagenome_out/pred_metagenome_contrib.tsv.gz', sep='\t')
df <- read.delim('picrust2_files/18S/picrust2_out_SHAI_18S/marker_predicted_and_nsti.tsv.gz', sep = '\t')
library(tidymodels)
library(tidyverse)
library(workflows)
library(tune)
library(metagMisc)
library(ranger)
library(randomForest)
library(janitor)
library(tidymodels)
library(tidyverse)
library(workflows)
library(tune)
library(metagMisc)
library(ranger)
library(randomForest)
func <- read.delim('picrust2_files/18S/EC_metagenome_out/pred_metagenome_contrib.tsv.gz', sep='\t')
df <- read.delim('picrust2_files/18S/picrust2_out_SHAI_18S/marker_nsti_predicted.tsv.gz', sep = '\t')
View(df)
names(df) <- c("taxon", "genome_18S_count", "metadata_NSTI")
func <- func %>%
full_join(df, by="taxon")
data.18S <- read.delim('metadata/SHAI.Meta.6September2023.q2.18S.txt', sep = '\t')
View(data.18S)
View(func)
qPCR_18S_df <- data.18S[,c(1,3)]
View(qPCR_18S_df)
colnames(qPCR_18S_df)[1] <- "sample"
func <- merge(func, qPCR_18S_df, by = "sample")
func <- func %>%
filter(!is.na(qPCR_18S))
func$gene_counts <- func$taxon_rel_abun / 100 * func$genome_function_count / func$genome_16S_count * func$qPCR
func$gene_counts <- func$taxon_rel_abun / 100 * func$genome_function_count / func$genome_18S_count * func$qPCR_18S
colnames(func)[2] <- "EC"
otu <- func %>%
group_by(sample, EC) %>%
summarize(sum=sum(gene_counts))
otu <- otu %>%
spread(key=sample, value=sum)
otu <- data.frame(otu)
otu[is.na(otu)] <- 0
row.names(otu) <- otu$EC
otu <- otu[,-1]
otu <- t(otu)
# convert matrix to data frame
otu <- as.data.frame(otu)
View(otu)
otu <- tibble::rownames_to_column(otu, "SampleID")
SHAI18S_all <- merge(data.18S, otu, by = "SampleID")
View(SHAI18S_all)
SHAI18S_all <- as.data.frame(SHAI18S_all)
saveRDS(SHAI18S_ml, "machine_learning/18S_EC/SHAI18S_ml_EC.RDS")
SHAI18S_ml <- as.data.frame(SHAI18S_all)
saveRDS(SHAI18S_ml, "machine_learning/18S_EC/SHAI18S_ml_EC.RDS")
saveRDS(SHAI18S_ml, "machine_learning/18S_EC/SHAI18S_ml_EC.RDS")
SHAI18S_ml <- readRDS("machine_learning/18S_EC/SHAI18S_ml_EC.RDS")
View(SHAI18S_ml)
SHAI18S_ml_CASH <- ml_all_meta[,c(115,154:1282)]
SHAI18S_ml_CASH <- SHAI18S_ml[,c(115,154:1282)]
View(SHAI18S_ml_CASH)
soil_split <- initial_split(SHAI18S_ml_CASH, prop = 4/5)
soil_split
soil_train <- training(soil_split)
soil_test <- testing(soil_split)
# cross validation
soil_cv <- vfold_cv(soil_train, v = 5, repeats = 10, strata = NULL)
soil_recipe <- recipe(Overall ~ ., data = SHAI18S_ml_CASH)
SHAI18S_ml_CASH <- SHAI18S_ml[,c(97,154:1282)]
soil_split <- initial_split(SHAI18S_ml_CASH, prop = 4/5)
soil_split
# 252 samples in training, 64 in testing, 316 total
# extract the train and test sets
soil_train <- training(soil_split)
soil_test <- testing(soil_split)
# cross validation
soil_cv <- vfold_cv(soil_train, v = 5, repeats = 10, strata = NULL)
# define a "recipe", i.e., the role of each variable in the model
# predicting overall CASH rating, and all other variables (ECs) are predictors
# if pre-processing steps or checks are needed (e.g., normalization), can use ?selections to see what selectors can be used
soil_recipe <- recipe(Overall ~ ., data = SHAI18S_ml_CASH)
soil_recipe
